<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Duel Trials Moto Challenge (2-Player)</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Inter:wght@400;700&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e; /* Deep space blue */
            color: #f3f4f6;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1rem;
            min-height: 100vh;
        }
        
        .game-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 1.5rem;
            color: #e94560; /* Neon Red Accent */
            text-shadow: 2px 2px 0 #0f0f1a;
        }

        #game-container {
            border: 4px solid #e94560; 
            box-shadow: 0 0 30px rgba(233, 69, 96, 0.5); /* Neon glow */
            max-width: 900px;
            width: 95vw;
            aspect-ratio: 16 / 9;
            margin: 10px auto;
            border-radius: 0.5rem;
            overflow: hidden;
            position: relative;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, #2e4a6a, #1a1a2e); /* Dark gradient sky */
        }
        
        .controls-card {
            background-color: #0f0f1a;
            padding: 1rem;
            border-radius: 0.75rem;
            margin-top: 1rem;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.7);
        }

        .button-style {
            background-color: #16213e; 
            color: #f3f4f6;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: bold;
            box-shadow: 0 3px #0f0f1a;
            transition: all 0.1s ease;
            user-select: none;
            cursor: pointer;
            min-width: 80px;
            text-align: center;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.75rem;
        }
        .button-style:active {
            box-shadow: 0 0 #0f0f1a;
            transform: translateY(3px);
        }
        .p1-controls .button-style {
            background-color: #ef4444; /* Red */
            box-shadow: 0 3px #b91c1c;
        }
        .p2-controls .button-style {
            background-color: #3b82f6; /* Blue */
            box-shadow: 0 3px #1d4ed8;
        }
        .status-panel {
            font-family: 'Inter', sans-serif;
            font-size: 0.9rem;
        }
    </style>
    <!-- Firebase Imports -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, collection, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // Expose Firebase utilities globally for use in the main script
        window.firebase = {
            initializeApp, getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged,
            getFirestore, doc, getDoc, setDoc, collection, setLogLevel
        };
    </script>
</head>
<body class="p-4">

    <header class="text-center mb-6 w-full max-w-4xl">
        <h1 class="game-title text-xl md:text-3xl mb-2">DUEL TRIALS CHALLENGE</h1>
        <div id="status-display" class="status-panel mt-3 bg-gray-800 p-2 rounded-lg text-xs font-mono">
            <p id="auth-status" class="text-yellow-400">Initializing...</p>
            <p id="high-score-status" class="text-green-400">Track Record: --</p>
        </div>
    </header>

    <div id="game-container" class="mx-auto rounded-xl">
        <canvas id="gameCanvas"></canvas>
    </div>

    <!-- Controls and Challenge Info -->
    <div class="controls-card mx-auto max-w-4xl w-full text-center">
        <div class="flex flex-col md:flex-row justify-between items-center mb-4">
             <button id="btnNewTrack" class="button-style bg-purple-500 hover:bg-purple-600 shadow-purple-800/80 mb-3 md:mb-0">NEW TRACK</button>
            <span class="text-gray-400 font-mono text-sm">CURRENT SEED: <span id="track-seed" class="text-yellow-400 font-bold"></span></span>
            <button id="btnRestart" class="button-style bg-yellow-500 hover:bg-yellow-600 active:shadow-none shadow-yellow-800/80 mt-3 md:mt-0">RESTART (SPACE)</button>
        </div>
        
        <div class="grid grid-cols-2 gap-4">
            <!-- Player 1 Controls -->
            <div class="p1-controls">
                <h2 class="text-lg font-bold mb-3 text-red-400">PLAYER 1 (WASD)</h2>
                <div class="grid grid-cols-4 gap-2">
                    <button id="p1-leanFwd" class="button-style"><span class="text-xs">A</span></button>
                    <button id="p1-throttle" class="button-style"><span class="text-xs">W (GAS)</span></button>
                    <button id="p1-brake" class="button-style"><span class="text-xs">S (BRAKE)</span></button>
                    <button id="p1-leanBack" class="button-style"><span class="text-xs">D</span></button>
                </div>
            </div>
            
            <!-- Player 2 Controls -->
            <div class="p2-controls">
                <h2 class="text-lg font-bold mb-3 text-blue-400">PLAYER 2 (ARROWS)</h2>
                <div class="grid grid-cols-4 gap-2">
                    <button id="p2-leanFwd" class="button-style"><span class="text-xs">&larr;</span></button>
                    <button id="p2-throttle" class="button-style"><span class="text-xs">&uarr; (GAS)</span></button>
                    <button id="p2-brake" class="button-style"><span class="text-xs">&darr; (BRAKE)</span></button>
                    <button id="p2-leanBack" class="button-style"><span class="text-xs">&rarr;</span></button>
                </div>
            </div>
        </div>

    </div>
    
    <div id="messageBox" class="fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-gray-900 text-white p-6 rounded-lg shadow-2xl hidden font-bold text-xl md:text-3xl z-50 transition-opacity duration-300 pointer-events-none border-4 border-red-500 text-center"></div>

    <script type="module">
        // Global Firebase Instances
        let app, db, auth, userId;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;

        // --- GAME CONSTANTS AND INITIAL SETUP ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const messageBox = document.getElementById('messageBox');
        const scoreStatus = document.getElementById('high-score-status');
        const authStatus = document.getElementById('auth-status');
        const trackSeedDisplay = document.getElementById('track-seed');

        let currentSeed = 2000;
        let bestTimeMs = Infinity;
        const CAMERA_OFFSET = 0.3; // Keep the leading player 30% from the left edge

        // Base moto structure
        const baseMoto = {
            // Viewport/Canvas Y position (X is calculated based on scroll)
            x: 0, 
            y: 0, 
            // World X position (tracks distance traveled)
            worldX: 0, 
            vx: 0, vy: 0, angle: 0, angularVelocity: 0,
            wheelRadius: 10, wheelDist: 40, mass: 1, gravity: 0.5,
            throttlePower: 0.15, maxSpeed: 10, leanRate: 0.007,
            angularDamping: 0.97, isFinished: false,
            winner: false,
            crash: false,
            color: '' 
        };

        const moto1 = { ...baseMoto, color: '#ef4444', playerId: 1 }; // Red
        const moto2 = { ...baseMoto, color: '#3b82f6', playerId: 2 }; // Blue
        const players = [moto1, moto2];
        
        const game = {
            scrollX: 0, // World scroll offset
            segments: [], segmentLength: 40, maxSegments: 300, 
            segmentSmoother: 8, gameOver: false,
            terrainMaxHeight: 120, terrainMinHeight: 30,
            finishLine: 0, startTime: 0, endTime: 0,
            winnerId: null
        };
        
        // Input mapping
        const keys = { 
            w: false, s: false, a: false, d: false, 
            ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false 
        };

        // --- PRNG (Seeded Random Number Generator) ---
        let seed = 1;
        function seedRandom(s) {
            seed = s % 2147483647;
            if (seed <= 0) seed += 2147483646;
        }
        function random() {
            seed = (seed * 16807) % 2147483647;
            return (seed - 1) / 2147483646;
        }

        // --- DYNAMIC SIZING ---

        function resizeCanvas() {
            const container = document.getElementById('game-container');
            const width = container.clientWidth;
            canvas.width = width;
            canvas.height = width * (9 / 16);
            
            // Set initial Y position for the bikes
            const startY = canvas.height * 0.7 - 50; 
            moto1.y = startY; 
            moto2.y = startY; 
            
            // Set initial world X and calculate finish line
            const startX = 100; // Starting world X position
            moto1.worldX = startX;
            moto2.worldX = startX;
            game.finishLine = (game.maxSegments - 10) * game.segmentLength;
            game.scrollX = 0; // Reset scroll on resize
        }
        window.addEventListener('resize', resizeCanvas);


        // --- FIREBASE/HIGH SCORE LOGIC ---

        async function initFirebase() {
            authStatus.textContent = 'Authenticating...';
            try {
                if (firebaseConfig) {
                    firebase.setLogLevel('error');
                    app = firebase.initializeApp(firebaseConfig);
                    db = firebase.getFirestore(app);
                    auth = firebase.getAuth(app);
                    
                    const token = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
                    if (token) {
                        await firebase.signInWithCustomToken(auth, token);
                    } else {
                        await firebase.signInAnonymously(auth);
                    }
                    userId = auth.currentUser?.uid || crypto.randomUUID();
                    authStatus.textContent = `Authenticated (User ID: ${userId.substring(0, 8)}...)`;
                    loadHighScore();
                } else {
                    authStatus.textContent = 'Firebase Config Missing. Scores will not be saved.';
                }
            } catch (error) {
                console.error("Firebase init failed:", error);
                authStatus.textContent = `Auth Error: ${error.message}`;
            }
        }

        async function loadHighScore() {
            if (!db || !userId) return;

            const collectionPath = `/artifacts/${appId}/users/${userId}/duel_scores`;
            const docRef = firebase.doc(db, collectionPath, `track_seed_${currentSeed}`);
            scoreStatus.textContent = 'Loading Track Record...';
            
            try {
                const docSnap = await firebase.getDoc(docRef);
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    bestTimeMs = data.bestTimeMs || Infinity;
                    scoreStatus.textContent = `Track Record: ${(bestTimeMs / 1000).toFixed(2)}s (P${data.winnerId})`;
                } else {
                    bestTimeMs = Infinity;
                    scoreStatus.textContent = `Track Record: N/A`;
                }
            } catch (error) {
                console.error("Error loading high score:", error);
                scoreStatus.textContent = `Record Load Error.`;
            }
        }

        async function saveHighScore(timeMs, winnerId) {
            if (!db || !userId || timeMs >= bestTimeMs) return;

            const collectionPath = `/artifacts/${appId}/users/${userId}/duel_scores`;
            const docRef = firebase.doc(db, collectionPath, `track_seed_${currentSeed}`);
            
            const data = {
                seed: currentSeed,
                bestTimeMs: timeMs,
                winnerId: winnerId,
                timestamp: Date.now()
            };

            try {
                await firebase.setDoc(docRef, data);
                bestTimeMs = timeMs;
                scoreStatus.textContent = `NEW TRACK RECORD by P${winnerId}! ${(bestTimeMs / 1000).toFixed(2)}s`;
            } catch (error) {
                console.error("Error saving high score:", error);
            }
        }


        // --- INPUT HANDLERS ---

        function handleKey(event, isDown) {
            const key = event.key;
            // Map arrow keys and WASD/Space/R
            const allowedKeys = ['w', 's', 'a', 'd', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'r'];
            if (allowedKeys.includes(key)) {
                keys[key] = isDown;
                event.preventDefault(); 
            }
            if ((key === ' ' || key === 'r') && isDown && game.gameOver) {
                resetGame(currentSeed);
            }
        }

        window.addEventListener('keydown', (e) => handleKey(e, true));
        window.addEventListener('keyup', (e) => handleKey(e, false));

        function setupTouchControls() {
            const controls = {
                'p1-leanFwd': 'a', 'p1-throttle': 'w', 'p1-brake': 's', 'p1-leanBack': 'd',
                'p2-leanFwd': 'ArrowLeft', 'p2-throttle': 'ArrowUp', 'p2-brake': 'ArrowDown', 'p2-leanBack': 'ArrowRight'
            };

            Object.keys(controls).forEach(id => {
                const btn = document.getElementById(id);
                const key = controls[id];

                const startHandler = (e) => { e.preventDefault(); keys[key] = true; btn.classList.add('brightness-75'); };
                const endHandler = (e) => { e.preventDefault(); keys[key] = false; btn.classList.remove('brightness-75'); };

                btn.addEventListener('touchstart', startHandler);
                btn.addEventListener('touchend', endHandler);
                btn.addEventListener('mousedown', startHandler);
                btn.addEventListener('mouseup', endHandler);
            });

            document.getElementById('btnRestart').addEventListener('click', () => resetGame(currentSeed));
            document.getElementById('btnNewTrack').addEventListener('click', () => {
                const newSeed = Math.floor(Math.random() * 100000);
                resetGame(newSeed);
            });
        }

        // --- TERRAIN GENERATION ---

        function generateTerrain(inputSeed) {
            seedRandom(inputSeed);
            currentSeed = inputSeed;
            trackSeedDisplay.textContent = currentSeed;
            
            let segments = [];
            let lastY = canvas.height * 0.7; 
            let lastChange = 0; 

            for (let i = 0; i < game.maxSegments; i++) {
                const maxSegmentY = canvas.height * 0.9 - game.terrainMinHeight;
                const minSegmentY = canvas.height * 0.9 - game.terrainMaxHeight;

                let change = (random() - 0.5) * game.terrainMaxHeight / game.segmentSmoother;
                change += lastChange * 0.7; 
                change = Math.min(Math.max(change, -15), 15); 
                
                let nextY = lastY + change;
                
                nextY = Math.max(minSegmentY, Math.min(maxSegmentY, nextY));
                
                segments.push({
                    x1: i * game.segmentLength,
                    y1: lastY,
                    x2: (i + 1) * game.segmentLength,
                    y2: nextY,
                });
                
                lastY = nextY;
                lastChange = change;
            }
            game.segments = segments;
        }

        // --- PHYSICS HELPERS ---

        function getGroundData(globalX) {
            const segmentIndex = Math.floor(globalX / game.segmentLength);
            const segment = game.segments[segmentIndex];
            
            if (!segment || globalX < 0 || segmentIndex >= game.segments.length) {
                return { y: canvas.height, angle: 0 }; 
            }

            const relativeX = (globalX - segment.x1) / game.segmentLength;
            const y = segment.y1 + (segment.y2 - segment.y1) * relativeX;
            const angle = Math.atan2(segment.y2 - segment.y1, segment.x2 - segment.x1);

            return { y, angle };
        }

        // --- GAME LOGIC ---
        
        function checkFinishCondition() {
            if (game.winnerId) return;

            let winner = players.find(p => p.isFinished && !p.crash);
            
            if (winner) {
                game.winnerId = winner.playerId;
                game.gameOver = true;
                game.endTime = Date.now();
                
                const totalTimeMs = game.endTime - game.startTime;
                const totalTimeSeconds = (totalTimeMs / 1000).toFixed(2);
                
                let message = `PLAYER ${game.winnerId} WINS! Time: ${totalTimeSeconds}s.`;
                
                if (totalTimeMs < bestTimeMs) {
                    saveHighScore(totalTimeMs, game.winnerId);
                    message += `<br>NEW TRACK RECORD!`;
                }
                showMessage(message, 50000);
            }
        }
        
        function updatePlayer(moto, throttleKey, brakeKey, leanFwdKey, leanBackKey) {
            if (moto.isFinished || moto.crash || game.gameOver) return;
            
            // 1. Calculate Wheel Positions & Ground Data
            const wheels = [
                { offset: -moto.wheelDist / 2, ground: null }, // Rear
                { offset: moto.wheelDist / 2, ground: null }  // Front
            ];

            wheels.forEach(wheel => {
                const localX = wheel.offset * Math.cos(moto.angle);
                const localY = wheel.offset * Math.sin(moto.angle);
                
                // Use moto.worldX for ground data lookup
                const groundInfo = getGroundData(moto.worldX + localX); 
                
                wheel.worldY = moto.y + localY;
                wheel.ground = groundInfo;
            });
            
            // 2. Apply Forces
            let totalAx = 0;
            let totalAy = moto.gravity * moto.mass;
            let totalTorque = 0;

            // Apply gravity torque
            totalTorque += -moto.gravity * moto.mass * moto.wheelDist * 0.005 * Math.sin(moto.angle);

            // Manual leaning torque
            if (keys[leanFwdKey]) { totalTorque -= moto.leanRate * moto.mass * 10; } 
            else if (keys[leanBackKey]) { totalTorque += moto.leanRate * moto.mass * 10; }
            
            // 3. Collision and Driving Forces
            wheels.forEach(wheel => {
                const groundY = wheel.ground.y - moto.wheelRadius;
                const groundAngle = wheel.ground.angle;
                const depth = wheel.worldY - groundY;

                if (depth > 0) {
                    // Contact/Repulsion
                    const repulsionForce = depth * 0.7; 
                    totalAy -= repulsionForce;

                    // Road Normal (Perpendicular to road)
                    const roadNormalX = Math.sin(groundAngle);
                    const roadNormalY = -Math.cos(groundAngle);

                    totalAx += roadNormalX * repulsionForce * 0.5; 
                    totalAy += roadNormalY * repulsionForce * 0.5; 

                    // Drive/Brake Force (Tangent to road)
                    let driveForce = 0;
                    if (keys[throttleKey]) { driveForce += moto.throttlePower; } 
                    else if (keys[brakeKey]) { driveForce -= moto.throttlePower * 1.5; } 
                    else { driveForce -= moto.vx * 0.03; } // Rolling resistance

                    const roadTangentX = Math.cos(groundAngle);
                    const roadTangentY = Math.sin(groundAngle);

                    totalAx += roadTangentX * driveForce;
                    totalAy += roadTangentY * driveForce;

                    // Torque from collision point 
                    const torqueArm = wheel.offset;
                    totalTorque += (repulsionForce * torqueArm) * 0.001;
                }
            });
            
            // 4. Integration
            moto.vx += totalAx / moto.mass;
            moto.vy += totalAy / moto.mass;
            moto.vx *= 0.99;
            moto.vy *= 0.99;
            moto.vx = Math.min(Math.max(moto.vx, -moto.maxSpeed), moto.maxSpeed);

            moto.angularVelocity += totalTorque / (moto.mass * 20);
            moto.angularVelocity *= moto.angularDamping;
            moto.angle += moto.angularVelocity;

            // Update WORLD position (THIS WAS THE MISSING KEY)
            moto.worldX += moto.vx;
            moto.y += moto.vy;

            // 5. Game Over/Crash Condition
            const maxTiltAngle = Math.PI / 2.5;
            if (Math.abs(moto.angle) > maxTiltAngle && moto.worldX > 100) { 
                moto.crash = true;
                moto.vx = 0; moto.vy = 0;
                
                if (moto1.crash && moto2.crash) {
                    game.gameOver = true;
                    showMessage(`DOUBLE CRASH! No winner. Press RESTART.`, 50000);
                } else if (!game.winnerId) {
                    showMessage(`P${moto.playerId} CRASHED!`, 1500);
                }
            }
            
            if (moto.worldX > game.finishLine && !moto.isFinished) {
                moto.isFinished = true;
                checkFinishCondition();
            }
        }
        
        function updateScroll() {
            // Find the leading player's world X position
            let leadingWorldX = Math.max(moto1.worldX, moto2.worldX);

            // Calculate the target scroll needed to keep the leading bike at CAMERA_OFFSET (e.g., 30% from the left)
            const targetScrollX = leadingWorldX - (canvas.width * CAMERA_OFFSET);
            
            // Smoothly move the camera, but ensure scrollX is never negative
            if (targetScrollX > game.scrollX) {
                game.scrollX = Math.max(0, game.scrollX + (targetScrollX - game.scrollX) * 0.1);
            }

            // Update both bikes' viewport X position based on the new scroll
            moto1.x = moto1.worldX - game.scrollX;
            moto2.x = moto2.worldX - game.scrollX;
        }

        function update() {
            if (game.gameOver) return;
            
            // 1. Update Player Physics (updates worldX)
            updatePlayer(moto1, 'w', 's', 'a', 'd');
            updatePlayer(moto2, 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight');

            // 2. Update Camera (updates scrollX and moto.x)
            updateScroll();
        }

        // --- RENDERING ---

        function drawTerrain() {
            const roadColor = '#475569'; 
            const dirtColor = '#374151'; 

            // Draw Background (Hills)
            ctx.fillStyle = '#6b7280'; 
            ctx.beginPath();
            ctx.moveTo(0, canvas.height);
            seedRandom(currentSeed);
            for(let i = -100; i < canvas.width + 100; i+= 100) {
                const hillHeight = 100 + random() * 50;
                ctx.lineTo(i, canvas.height - hillHeight);
            }
            ctx.lineTo(canvas.width, canvas.height);
            ctx.fill();
            seedRandom(currentSeed);
            
            // Draw the ground mass (dirt)
            ctx.fillStyle = dirtColor;
            ctx.beginPath();
            ctx.moveTo(0, canvas.height);
            for (let i = 0; i < game.segments.length; i++) {
                const seg = game.segments[i];
                const x1 = seg.x1 - game.scrollX;
                const x2 = seg.x2 - game.scrollX;
                if (x2 < 0 || x1 > canvas.width) continue;
                ctx.lineTo(x1, seg.y1);
            }
            ctx.lineTo(canvas.width, canvas.height); 
            ctx.closePath();
            ctx.fill();

            // Draw the road surface line
            ctx.strokeStyle = roadColor;
            ctx.lineWidth = 6;
            ctx.lineJoin = 'round';
            ctx.beginPath();
            let started = false;
            for (let i = 0; i < game.segments.length; i++) {
                const seg = game.segments[i];
                const x1 = seg.x1 - game.scrollX;
                const x2 = seg.x2 - game.scrollX;

                if (x2 < 0 || x1 > canvas.width) continue;

                if (!started) {
                    ctx.moveTo(x1, seg.y1);
                    started = true;
                }
                ctx.lineTo(x2, seg.y2);
            }
            ctx.stroke();
            
            // Draw Finish Line
            const finishX = game.finishLine - game.scrollX;
            if (finishX > 0 && finishX < canvas.width) {
                ctx.strokeStyle = '#e94560'; 
                ctx.lineWidth = 10;
                ctx.beginPath();
                ctx.moveTo(finishX, 0);
                ctx.lineTo(finishX, canvas.height);
                ctx.stroke();
                
                ctx.font = '30px "Press Start 2P", cursive';
                ctx.fillStyle = '#e94560';
                ctx.textAlign = 'center';
                ctx.fillText('DUEL', finishX, 50);
            }
        }
        
        function drawBike(moto) {
            ctx.save();
            
            // Use moto.x (viewport position) for drawing
            ctx.translate(moto.x, moto.y); 
            ctx.rotate(moto.angle);

            const wheelOffsets = [-moto.wheelDist / 2, moto.wheelDist / 2]; 
            const wheelColor = '#1f2937';
            const rimColor = '#f3f4f6';

            ctx.globalAlpha = moto.crash ? 0.4 : 1.0; 

            // 1. Draw Wheels
            wheelOffsets.forEach(offset => {
                ctx.fillStyle = wheelColor;
                ctx.beginPath();
                ctx.arc(offset, 0, moto.wheelRadius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = rimColor;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(offset, 0, moto.wheelRadius * 0.5, 0, Math.PI * 2);
                ctx.stroke();
            });
            
            // 2. Draw Chassis (Player Color Frame)
            ctx.strokeStyle = moto.color; 
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(wheelOffsets[0], 0);
            ctx.lineTo(wheelOffsets[1], 0);
            ctx.stroke();
            
            // 3. Draw Rider/Body
            ctx.fillStyle = moto.color; 
            ctx.fillRect(-15, -15, 30, 10);
            ctx.strokeStyle = rimColor;
            ctx.strokeRect(-15, -15, 30, 10);
            
            // Player ID text
            ctx.font = '10px "Press Start 2P", cursive';
            ctx.fillStyle = rimColor;
            ctx.textAlign = 'center';
            ctx.fillText(`P${moto.playerId}`, 0, -5);


            ctx.restore();
            ctx.globalAlpha = 1.0;
        }

        let messageTimeout = null;
        function showMessage(text, duration) {
            messageBox.innerHTML = text;
            messageBox.style.display = 'block';
            messageBox.style.opacity = 1;
            
            if (text.includes("NEW TRACK RECORD") || text.includes("WINS")) {
                messageBox.classList.remove('border-red-500');
                messageBox.classList.add('border-green-500');
            } else {
                messageBox.classList.remove('border-green-500');
                messageBox.classList.add('border-red-500');
            }
            
            if (messageTimeout) clearTimeout(messageTimeout);
            if (duration < 50000) { 
                messageTimeout = setTimeout(() => {
                    messageBox.style.opacity = 0;
                    setTimeout(() => messageBox.style.display = 'none', 300);
                }, duration);
            }
        }

        function drawHUD() {
            const timeElapsed = game.gameOver ? (game.endTime - game.startTime) : (Date.now() - game.startTime);
            const timeSeconds = (timeElapsed / 1000).toFixed(2);
            
            ctx.font = '16px "Press Start 2P", cursive';
            ctx.textAlign = 'left';

            // TIME
            ctx.fillStyle = '#facc15'; 
            ctx.fillText(`TIME: ${timeSeconds}s`, 10, 30);
            
            // P1 STATUS
            const p1Status = moto1.isFinished ? 'FIN' : (moto1.crash ? 'CRASH' : 'RACING');
            ctx.fillStyle = moto1.color; 
            ctx.fillText(`P1: ${p1Status}`, 10, 60);

            // P2 STATUS
            const p2Status = moto2.isFinished ? 'FIN' : (moto2.crash ? 'CRASH' : 'RACING');
            ctx.fillStyle = moto2.color; 
            ctx.fillText(`P2: ${p2Status}`, 10, 90);

            // WORLD PROGRESS
            ctx.fillStyle = '#f3f4f6';
            ctx.textAlign = 'right';
            const progress = Math.min(100, Math.floor(Math.max(moto1.worldX, moto2.worldX) / game.finishLine * 100));
            ctx.fillText(`PROG: ${progress}%`, canvas.width - 10, 30);
        }


        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawTerrain();
            drawBike(moto2); 
            drawBike(moto1);
            drawHUD();
            requestAnimationFrame(draw);
        }

        // --- GAME LOOP AND CONTROLS ---

        function gameLoop() {
            update();
        }

        function resetGame(newSeed) {
            resizeCanvas(); 

            // Reset Players
            const startY = canvas.height * 0.7 - 50; 
            const startX = 100;
            
            // Helper to deep reset the bike object
            const resetBike = (moto) => {
                moto.worldX = startX;
                moto.y = startY;
                moto.vx = 0; moto.vy = 0; moto.angle = 0; moto.angularVelocity = 0;
                moto.isFinished = false; moto.crash = false;
            };

            resetBike(moto1);
            resetBike(moto2);

            // Reset game state
            game.scrollX = 0;
            game.gameOver = false;
            game.startTime = Date.now();
            game.winnerId = null;
            
            generateTerrain(newSeed); 
            loadHighScore(); 

            messageBox.style.display = 'none';
        }

        window.onload = function () {
            resizeCanvas(); 
            setupTouchControls();
            
            // Start Firebase and then the game
            initFirebase().then(() => {
                resetGame(currentSeed); 
                setInterval(gameLoop, 1000 / 60); 
                draw(); 
            });
            
            showMessage("P1: WASD | P2: Arrows. First to the finish wins the duel!", 4000);
        };
    </script>
</body>
</html>
